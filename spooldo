#!/usr/bin/env python

# Copyright (c) 2012 by Farsight Security, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import subprocess
import random
import shutil
import string
import sys
import time

class CommandTemplate(string.Template):
    delimiter = '%'

def start_job(cmd):
    sys.stderr.write(cmd + '\n')
    return subprocess.Popen(cmd, shell=True).pid

def waitproc(jobs):
    (pid, status) = os.wait()
    if pid in jobs:
        incoming_fname, active_fname, fname, archive_dnames = jobs[pid]
        if status != 0:
            try:
                os.unlink(active_fname)
            finally:
                error('command failed')
        archive_incoming(incoming_fname, fname, archive_dnames)
        del jobs[pid]
        sys.stderr.write('%s done\n' % active_fname)

def dirwalk(dirname):
    file_list = []
    for root, dirs, files in os.walk(dirname):
        for fname in files:
            if fname.startswith('.'):
                continue
            fname = os.path.join(root, fname)
            file_list.append(fname)
    if os.getenv('SPOOLDO_ORDERED'):
        file_list.sort()
    else:
        random.shuffle(file_list)
    return file_list

def same_filesystem(fname1, fname2):
    if os.stat(fname1).st_dev == os.stat(fname2).st_dev:
        return True
    return False

def archive_incoming(incoming_fname, fname, archive_dnames=[]):
    try:
        for archive_dname in archive_dnames:
            archive_fname = os.path.join(archive_dname, fname)
            if same_filesystem(incoming_fname, archive_dname):
                os.link(incoming_fname, archive_fname)
            else:
                shutil.copy(incoming_fname, archive_fname)
    finally:
        os.unlink(incoming_fname)

def do_spool(incoming_dname, active_dname, archive_dnames=[], cmd_tmpl=None):
    jobs = dict()
    try:
        limit = int(os.getenv("SPOOLDO_JOBS"))
        if limit < 1:
            limit = 1
    except:
        limit = 1
    try:
        for incoming_fname in dirwalk(incoming_dname):
            rel_fname = os.path.relpath(incoming_fname, incoming_dname)
            fname = rel_fname.replace(os.path.sep, '--')
            active_fname = os.path.join(active_dname, fname)

            try:
                if os.path.isfile(active_fname):
                    continue
                os.link(incoming_fname, active_fname)
            except:
                warn('unable to link %s to %s' % (incoming_fname, active_fname))
                continue

            if cmd_tmpl:
                pid = start_job(CommandTemplate(cmd_tmpl).substitute(fname=active_fname))
                jobs[pid] = (incoming_fname, active_fname, fname, archive_dnames)
                if len(jobs) == limit:
                        waitproc(jobs)
            else:
                archive_incoming(incoming_fname, fname, archive_dnames)
    finally:
        while len(jobs) > 0:
            waitproc(jobs)

def warn(msg):
    sys.stderr.write('spooldo: warning: %s\n' % msg)

def error(msg):
    sys.stderr.write('spooldo: error: %s\n' % msg)
    sys.exit(1)

def main(incoming_dname, active_dname, archive_dnames=[]):
    incoming_dname = os.path.realpath(incoming_dname)
    active_dname = os.path.realpath(active_dname)

    if not os.path.isdir(incoming_dname):
        error('"%s" is not a directory.' % incoming_dname)
    if not os.path.isdir(active_dname):
        error('"%s" is not a directory.' % active_dname)

    if not same_filesystem(incoming_dname, active_dname):
        error('incoming directory and active directory are not on the same filesystem.')

    if archive_dnames:
        for archive_dname in archive_dnames:
            archive_dname = os.path.realpath(archive_dname)

            if not os.path.isdir(archive_dname):
                error('"%s" is not a directory.' % archive_dname)

            if os.path.samefile(incoming_dname, archive_dname):
                error('incoming directory and archive directory are the same.')
            if os.path.samefile(active_dname, archive_dname):
                error('active directory and archive directory are the same.')

    if os.path.samefile(incoming_dname, active_dname):
        error('incoming directory and active directory are the same.')

    cmd_tmpl = os.getenv('SPOOLDO_COMMAND_TEMPLATE')

    while True:
        try:
            do_spool(incoming_dname, active_dname, archive_dnames, cmd_tmpl)
        except:
            pass
        time.sleep(1)

if __name__ == '__main__':
    if len(sys.argv) == 3:
        main(sys.argv[1], sys.argv[2])
    elif len(sys.argv) > 3:
        main(sys.argv[1], sys.argv[2], sys.argv[3:])
    else:
        sys.stderr.write('Usage: %s <INCOMING DIR> <ACTIVE DIR> [<ARCHIVE DIR> ... <ARCHIVE DIR>]\n' % sys.argv[0])
        sys.exit(1)
